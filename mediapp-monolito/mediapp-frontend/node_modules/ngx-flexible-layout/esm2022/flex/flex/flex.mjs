/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, Inject, Injectable, Input } from '@angular/core';
import { BaseDirective2, LAYOUT_CONFIG, StyleBuilder, validateBasis } from 'ngx-flexible-layout/core';
import { takeUntil } from 'rxjs/operators';
import { extendObject, isFlowHorizontal } from 'ngx-flexible-layout/_private-utils';
import * as i0 from "@angular/core";
import * as i1 from "ngx-flexible-layout/core";
export class FlexStyleBuilder extends StyleBuilder {
    layoutConfig;
    constructor(layoutConfig) {
        super();
        this.layoutConfig = layoutConfig;
    }
    buildStyles(input, parent) {
        let [grow, shrink, ...basisParts] = input.split(' ');
        let basis = basisParts.join(' ');
        // The flex-direction of this element's flex container. Defaults to 'row'.
        const direction = (parent.direction.indexOf('column') > -1) ? 'column' : 'row';
        const max = isFlowHorizontal(direction) ? 'max-width' : 'max-height';
        const min = isFlowHorizontal(direction) ? 'min-width' : 'min-height';
        const hasCalc = String(basis).indexOf('calc') > -1;
        const usingCalc = hasCalc || (basis === 'auto');
        const isPercent = String(basis).indexOf('%') > -1 && !hasCalc;
        const hasUnits = String(basis).indexOf('px') > -1 || String(basis).indexOf('rem') > -1 ||
            String(basis).indexOf('em') > -1 || String(basis).indexOf('vw') > -1 ||
            String(basis).indexOf('vh') > -1;
        let isValue = (hasCalc || hasUnits);
        grow = (grow == '0') ? 0 : grow;
        shrink = (shrink == '0') ? 0 : shrink;
        // make box inflexible when shrink and grow are both zero
        // should not set a min when the grow is zero
        // should not set a max when the shrink is zero
        const isFixed = !grow && !shrink;
        let css = {};
        // flex-basis allows you to specify the initial/starting main-axis size of the element,
        // before anything else is computed. It can either be a percentage or an absolute value.
        // It is, however, not the breaking point for flex-grow/shrink properties
        //
        // flex-grow can be seen as this:
        //   0: Do not stretch. Either size to element's content width, or obey 'flex-basis'.
        //   1: (Default value). Stretch; will be the same size to all other flex items on
        //       the same row since they have a default value of 1.
        //   ≥2 (integer n): Stretch. Will be n times the size of other elements
        //      with 'flex-grow: 1' on the same row.
        // Use `null` to clear existing styles.
        const clearStyles = {
            'max-width': null,
            'max-height': null,
            'min-width': null,
            'min-height': null
        };
        switch (basis || '') {
            case '':
                const useColumnBasisZero = this.layoutConfig.useColumnBasisZero !== false;
                basis = direction === 'row' ? '0%' : (useColumnBasisZero ? '0.000000001px' : 'auto');
                break;
            case 'initial': // default
            case 'nogrow':
                grow = 0;
                basis = 'auto';
                break;
            case 'grow':
                basis = '100%';
                break;
            case 'noshrink':
                shrink = 0;
                basis = 'auto';
                break;
            case 'auto':
                break;
            case 'none':
                grow = 0;
                shrink = 0;
                basis = 'auto';
                break;
            default:
                // Defaults to percentage sizing unless `px` is explicitly set
                if (!isValue && !isPercent && !isNaN(basis)) {
                    basis = basis + '%';
                }
                // Fix for issue 280
                if (basis === '0%') {
                    isValue = true;
                }
                if (basis === '0px') {
                    basis = '0%';
                }
                // fix issue #5345
                if (hasCalc) {
                    css = extendObject(clearStyles, {
                        'flex-grow': grow,
                        'flex-shrink': shrink,
                        'flex-basis': isValue ? basis : '100%'
                    });
                }
                else {
                    css = extendObject(clearStyles, {
                        'flex': `${grow} ${shrink} ${isValue ? basis : '100%'}`
                    });
                }
                break;
        }
        if (!(css['flex'] || css['flex-grow'])) {
            if (hasCalc) {
                css = extendObject(clearStyles, {
                    'flex-grow': grow,
                    'flex-shrink': shrink,
                    'flex-basis': basis
                });
            }
            else {
                css = extendObject(clearStyles, {
                    'flex': `${grow} ${shrink} ${basis}`
                });
            }
        }
        // Fix for issues 277, 534, and 728
        if (basis !== '0%' && basis !== '0px' && basis !== '0.000000001px' && basis !== 'auto') {
            css[min] = isFixed || (isValue && grow) ? basis : null;
            css[max] = isFixed || (!usingCalc && shrink) ? basis : null;
        }
        // Fix for issue 528
        if (!css[min] && !css[max]) {
            if (hasCalc) {
                css = extendObject(clearStyles, {
                    'flex-grow': grow,
                    'flex-shrink': shrink,
                    'flex-basis': basis
                });
            }
            else {
                css = extendObject(clearStyles, {
                    'flex': `${grow} ${shrink} ${basis}`
                });
            }
        }
        else {
            // Fix for issue 660
            if (parent.hasWrap) {
                css[hasCalc ? 'flex-basis' : 'flex'] = css[max] ?
                    (hasCalc ? css[max] : `${grow} ${shrink} ${css[max]}`) :
                    (hasCalc ? css[min] : `${grow} ${shrink} ${css[min]}`);
            }
        }
        return extendObject(css, { 'box-sizing': 'border-box' });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.4", ngImport: i0, type: FlexStyleBuilder, deps: [{ token: LAYOUT_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.4", ngImport: i0, type: FlexStyleBuilder, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.4", ngImport: i0, type: FlexStyleBuilder, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LAYOUT_CONFIG]
                }] }] });
const inputs = [
    'fxFlex', 'fxFlex.xs', 'fxFlex.sm', 'fxFlex.md',
    'fxFlex.lg', 'fxFlex.xl', 'fxFlex.lt-sm', 'fxFlex.lt-md',
    'fxFlex.lt-lg', 'fxFlex.lt-xl', 'fxFlex.gt-xs', 'fxFlex.gt-sm',
    'fxFlex.gt-md', 'fxFlex.gt-lg'
];
const selector = `
  [fxFlex], [fxFlex.xs], [fxFlex.sm], [fxFlex.md],
  [fxFlex.lg], [fxFlex.xl], [fxFlex.lt-sm], [fxFlex.lt-md],
  [fxFlex.lt-lg], [fxFlex.lt-xl], [fxFlex.gt-xs], [fxFlex.gt-sm],
  [fxFlex.gt-md], [fxFlex.gt-lg]
`;
/**
 * Directive to control the size of a flex item using flex-basis, flex-grow, and flex-shrink.
 * Corresponds to the css `flex` shorthand property.
 *
 * @see https://css-tricks.com/snippets/css/a-guide-to-flexbox/
 */
export class FlexDirective extends BaseDirective2 {
    layoutConfig;
    marshal;
    DIRECTIVE_KEY = 'flex';
    direction = undefined;
    wrap = undefined;
    get shrink() { return this.flexShrink; }
    set shrink(value) {
        this.flexShrink = value || '1';
        this.triggerReflow();
    }
    get grow() { return this.flexGrow; }
    set grow(value) {
        this.flexGrow = value || '1';
        this.triggerReflow();
    }
    flexGrow = '1';
    flexShrink = '1';
    constructor(elRef, styleUtils, layoutConfig, styleBuilder, marshal) {
        super(elRef, styleBuilder, styleUtils, marshal);
        this.layoutConfig = layoutConfig;
        this.marshal = marshal;
        this.init();
    }
    ngOnInit() {
        if (this.parentElement) {
            this.marshal.trackValue(this.parentElement, 'layout')
                .pipe(takeUntil(this.destroySubject))
                .subscribe(this.onLayoutChange.bind(this));
            this.marshal.trackValue(this.nativeElement, 'layout-align')
                .pipe(takeUntil(this.destroySubject))
                .subscribe(this.triggerReflow.bind(this));
        }
    }
    /**
     * Caches the parent container's 'flex-direction' and updates the element's style.
     * Used as a handler for layout change events from the parent flex container.
     */
    onLayoutChange(matcher) {
        const layout = matcher.value;
        const layoutParts = layout.split(' ');
        this.direction = layoutParts[0];
        this.wrap = layoutParts[1] !== undefined && layoutParts[1] === 'wrap';
        this.triggerUpdate();
    }
    /** Input to this is exclusively the basis input value */
    updateWithValue(value) {
        const addFlexToParent = this.layoutConfig.addFlexToParent !== false;
        if (this.direction === undefined) {
            this.direction = this.getFlexFlowDirection(this.parentElement, addFlexToParent);
        }
        if (this.wrap === undefined) {
            this.wrap = this.hasWrap(this.parentElement);
        }
        const direction = this.direction;
        const isHorizontal = direction.startsWith('row');
        const hasWrap = this.wrap;
        if (isHorizontal && hasWrap) {
            this.styleCache = flexRowWrapCache;
        }
        else if (isHorizontal && !hasWrap) {
            this.styleCache = flexRowCache;
        }
        else if (!isHorizontal && hasWrap) {
            this.styleCache = flexColumnWrapCache;
        }
        else if (!isHorizontal && !hasWrap) {
            this.styleCache = flexColumnCache;
        }
        const basis = String(value).replace(';', '');
        const parts = validateBasis(basis, this.flexGrow, this.flexShrink);
        this.addStyles(parts.join(' '), { direction, hasWrap });
    }
    /** Trigger a style reflow, usually based on a shrink/grow input event */
    triggerReflow() {
        const activatedValue = this.activatedValue;
        if (activatedValue !== undefined) {
            const parts = validateBasis(activatedValue + '', this.flexGrow, this.flexShrink);
            this.marshal.updateElement(this.nativeElement, this.DIRECTIVE_KEY, parts.join(' '));
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.4", ngImport: i0, type: FlexDirective, deps: [{ token: i0.ElementRef }, { token: i1.StyleUtils }, { token: LAYOUT_CONFIG }, { token: FlexStyleBuilder }, { token: i1.MediaMarshaller }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.0.4", type: FlexDirective, inputs: { shrink: ["fxShrink", "shrink"], grow: ["fxGrow", "grow"] }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.4", ngImport: i0, type: FlexDirective, decorators: [{
            type: Directive
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.StyleUtils }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LAYOUT_CONFIG]
                }] }, { type: FlexStyleBuilder }, { type: i1.MediaMarshaller }], propDecorators: { shrink: [{
                type: Input,
                args: ['fxShrink']
            }], grow: [{
                type: Input,
                args: ['fxGrow']
            }] } });
export class DefaultFlexDirective extends FlexDirective {
    inputs = inputs;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.4", ngImport: i0, type: DefaultFlexDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.0.4", type: DefaultFlexDirective, selector: "\n  [fxFlex], [fxFlex.xs], [fxFlex.sm], [fxFlex.md],\n  [fxFlex.lg], [fxFlex.xl], [fxFlex.lt-sm], [fxFlex.lt-md],\n  [fxFlex.lt-lg], [fxFlex.lt-xl], [fxFlex.gt-xs], [fxFlex.gt-sm],\n  [fxFlex.gt-md], [fxFlex.gt-lg]\n", inputs: { fxFlex: "fxFlex", "fxFlex.xs": "fxFlex.xs", "fxFlex.sm": "fxFlex.sm", "fxFlex.md": "fxFlex.md", "fxFlex.lg": "fxFlex.lg", "fxFlex.xl": "fxFlex.xl", "fxFlex.lt-sm": "fxFlex.lt-sm", "fxFlex.lt-md": "fxFlex.lt-md", "fxFlex.lt-lg": "fxFlex.lt-lg", "fxFlex.lt-xl": "fxFlex.lt-xl", "fxFlex.gt-xs": "fxFlex.gt-xs", "fxFlex.gt-sm": "fxFlex.gt-sm", "fxFlex.gt-md": "fxFlex.gt-md", "fxFlex.gt-lg": "fxFlex.gt-lg" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.4", ngImport: i0, type: DefaultFlexDirective, decorators: [{
            type: Directive,
            args: [{ inputs, selector }]
        }] });
const flexRowCache = new Map();
const flexColumnCache = new Map();
const flexRowWrapCache = new Map();
const flexColumnWrapCache = new Map();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxleC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2xpYnMvZmxleC1sYXlvdXQvZmxleC9mbGV4L2ZsZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBQ0gsT0FBTyxFQUFFLFNBQVMsRUFBYyxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUN6RixPQUFPLEVBQ0gsY0FBYyxFQUNkLGFBQWEsRUFBbUIsWUFBWSxFQUU1QyxhQUFhLEVBQ2hCLE1BQU0sMEJBQTBCLENBQUM7QUFDbEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQzs7O0FBUXBGLE1BQU0sT0FBTyxnQkFBaUIsU0FBUSxZQUFZO0lBQ0g7SUFBN0MsWUFBNkMsWUFBaUM7UUFDNUUsS0FBSyxFQUFFLENBQUM7UUFEbUMsaUJBQVksR0FBWixZQUFZLENBQXFCO0lBRTlFLENBQUM7SUFDRCxXQUFXLENBQUMsS0FBYSxFQUFFLE1BQXlCO1FBQ2xELElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsVUFBVSxDQUFDLEdBQXNCLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEUsSUFBSSxLQUFLLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVqQywwRUFBMEU7UUFDMUUsTUFBTSxTQUFTLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUUvRSxNQUFNLEdBQUcsR0FBRyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENB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RixJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3JGO0lBQ0gsQ0FBQzt1R0F6RlUsYUFBYSxzRUEwQkosYUFBYTsyRkExQnRCLGFBQWE7OzJGQUFiLGFBQWE7a0JBRHpCLFNBQVM7OzBCQTJCSyxNQUFNOzJCQUFDLGFBQWE7bUdBbEI3QixNQUFNO3NCQURULEtBQUs7dUJBQUMsVUFBVTtnQkFRYixJQUFJO3NCQURQLEtBQUs7dUJBQUMsUUFBUTs7QUErRWpCLE1BQU0sT0FBTyxvQkFBcUIsU0FBUSxhQUFhO0lBQ2xDLE1BQU0sR0FBRyxNQUFNLENBQUM7dUdBRHhCLG9CQUFvQjsyRkFBcEIsb0JBQW9COzsyRkFBcEIsb0JBQW9CO2tCQURoQyxTQUFTO21CQUFDLEVBQUMsTUFBTSxFQUFFLFFBQVEsRUFBQzs7QUFLN0IsTUFBTSxZQUFZLEdBQWlDLElBQUksR0FBRyxFQUFFLENBQUM7QUFDN0QsTUFBTSxlQUFlLEdBQWlDLElBQUksR0FBRyxFQUFFLENBQUM7QUFDaEUsTUFBTSxnQkFBZ0IsR0FBaUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNqRSxNQUFNLG1CQUFtQixHQUFpQyxJQUFJLEdBQUcsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBCYXNlRGlyZWN0aXZlMiwgRWxlbWVudE1hdGNoZXIsIExheW91dENvbmZpZ09wdGlvbnMsXG4gICAgTEFZT1VUX0NPTkZJRywgTWVkaWFNYXJzaGFsbGVyLCBTdHlsZUJ1aWxkZXIsXG4gICAgU3R5bGVEZWZpbml0aW9uLCBTdHlsZVV0aWxzLFxuICAgIHZhbGlkYXRlQmFzaXNcbn0gZnJvbSAnbmd4LWZsZXhpYmxlLWxheW91dC9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgZXh0ZW5kT2JqZWN0LCBpc0Zsb3dIb3Jpem9udGFsIH0gZnJvbSAnbmd4LWZsZXhpYmxlLWxheW91dC9fcHJpdmF0ZS11dGlscyc7XG5cbmludGVyZmFjZSBGbGV4QnVpbGRlclBhcmVudCB7XG4gIGRpcmVjdGlvbjogc3RyaW5nO1xuICBoYXNXcmFwOiBib29sZWFuO1xufVxuXG5ASW5qZWN0YWJsZSh7cHJvdmlkZWRJbjogJ3Jvb3QnfSlcbmV4cG9ydCBjbGFzcyBGbGV4U3R5bGVCdWlsZGVyIGV4dGVuZHMgU3R5bGVCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IoQEluamVjdChMQVlPVVRfQ09ORklHKSBwcm90ZWN0ZWQgbGF5b3V0Q29uZmlnOiBMYXlvdXRDb25maWdPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICBidWlsZFN0eWxlcyhpbnB1dDogc3RyaW5nLCBwYXJlbnQ6IEZsZXhCdWlsZGVyUGFyZW50KSB7XG4gICAgbGV0IFtncm93LCBzaHJpbmssIC4uLmJhc2lzUGFydHNdOiAoc3RyaW5nfG51bWJlcilbXSA9IGlucHV0LnNwbGl0KCcgJyk7XG4gICAgbGV0IGJhc2lzID0gYmFzaXNQYXJ0cy5qb2luKCcgJyk7XG5cbiAgICAvLyBUaGUgZmxleC1kaXJlY3Rpb24gb2YgdGhpcyBlbGVtZW50J3MgZmxleCBjb250YWluZXIuIERlZmF1bHRzIHRvICdyb3cnLlxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IChwYXJlbnQuZGlyZWN0aW9uLmluZGV4T2YoJ2NvbHVtbicpID4gLTEpID8gJ2NvbHVtbicgOiAncm93JztcblxuICAgIGNvbnN0IG1heCA9IGlzRmxvd0hvcml6b250YWwoZGlyZWN0aW9uKSA/ICdtYXgtd2lkdGgnIDogJ21heC1oZWlnaHQnO1xuICAgIGNvbnN0IG1pbiA9IGlzRmxvd0hvcml6b250YWwoZGlyZWN0aW9uKSA/ICdtaW4td2lkdGgnIDogJ21pbi1oZWlnaHQnO1xuXG4gICAgY29uc3QgaGFzQ2FsYyA9IFN0cmluZyhiYXNpcykuaW5kZXhPZignY2FsYycpID4gLTE7XG4gICAgY29uc3QgdXNpbmdDYWxjID0gaGFzQ2FsYyB8fCAoYmFzaXMgPT09ICdhdXRvJyk7XG4gICAgY29uc3QgaXNQZXJjZW50ID0gU3RyaW5nKGJhc2lzKS5pbmRleE9mKCclJykgPiAtMSAmJiAhaGFzQ2FsYztcbiAgICBjb25zdCBoYXNVbml0cyA9IFN0cmluZyhiYXNpcykuaW5kZXhPZigncHgnKSA+IC0xIHx8IFN0cmluZyhiYXNpcykuaW5kZXhPZigncmVtJykgPiAtMSB8fFxuICAgICAgU3RyaW5nKGJhc2lzKS5pbmRleE9mKCdlbScpID4gLTEgfHwgU3RyaW5nKGJhc2lzKS5pbmRleE9mKCd2dycpID4gLTEgfHxcbiAgICAgIFN0cmluZyhiYXNpcykuaW5kZXhPZigndmgnKSA+IC0xO1xuXG4gICAgbGV0IGlzVmFsdWUgPSAoaGFzQ2FsYyB8fCBoYXNVbml0cyk7XG5cbiAgICBncm93ID0gKGdyb3cgPT0gJzAnKSA/IDAgOiBncm93O1xuICAgIHNocmluayA9IChzaHJpbmsgPT0gJzAnKSA/IDAgOiBzaHJpbms7XG5cbiAgICAvLyBtYWtlIGJveCBpbmZsZXhpYmxlIHdoZW4gc2hyaW5rIGFuZCBncm93IGFyZSBib3RoIHplcm9cbiAgICAvLyBzaG91bGQgbm90IHNldCBhIG1pbiB3aGVuIHRoZSBncm93IGlzIHplcm9cbiAgICAvLyBzaG91bGQgbm90IHNldCBhIG1heCB3aGVuIHRoZSBzaHJpbmsgaXMgemVyb1xuICAgIGNvbnN0IGlzRml4ZWQgPSAhZ3JvdyAmJiAhc2hyaW5rO1xuXG4gICAgbGV0IGNzczoge1trZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IG51bGx9ID0ge307XG5cbiAgICAvLyBmbGV4LWJhc2lzIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgaW5pdGlhbC9zdGFydGluZyBtYWluLWF4aXMgc2l6ZSBvZiB0aGUgZWxlbWVudCxcbiAgICAvLyBiZWZvcmUgYW55dGhpbmcgZWxzZSBpcyBjb21wdXRlZC4gSXQgY2FuIGVpdGhlciBiZSBhIHBlcmNlbnRhZ2Ugb3IgYW4gYWJzb2x1dGUgdmFsdWUuXG4gICAgLy8gSXQgaXMsIGhvd2V2ZXIsIG5vdCB0aGUgYnJlYWtpbmcgcG9pbnQgZm9yIGZsZXgtZ3Jvdy9zaHJpbmsgcHJvcGVydGllc1xuICAgIC8vXG4gICAgLy8gZmxleC1ncm93IGNhbiBiZSBzZWVuIGFzIHRoaXM6XG4gICAgLy8gICAwOiBEbyBub3Qgc3RyZXRjaC4gRWl0aGVyIHNpemUgdG8gZWxlbWVudCdzIGNvbnRlbnQgd2lkdGgsIG9yIG9iZXkgJ2ZsZXgtYmFzaXMnLlxuICAgIC8vICAgMTogKERlZmF1bHQgdmFsdWUpLiBTdHJldGNoOyB3aWxsIGJlIHRoZSBzYW1lIHNpemUgdG8gYWxsIG90aGVyIGZsZXggaXRlbXMgb25cbiAgICAvLyAgICAgICB0aGUgc2FtZSByb3cgc2luY2UgdGhleSBoYXZlIGEgZGVmYXVsdCB2YWx1ZSBvZiAxLlxuICAgIC8vICAg4omlMiAoaW50ZWdlciBuKTogU3RyZXRjaC4gV2lsbCBiZSBuIHRpbWVzIHRoZSBzaXplIG9mIG90aGVyIGVsZW1lbnRzXG4gICAgLy8gICAgICB3aXRoICdmbGV4LWdyb3c6IDEnIG9uIHRoZSBzYW1lIHJvdy5cblxuICAgIC8vIFVzZSBgbnVsbGAgdG8gY2xlYXIgZXhpc3Rpbmcgc3R5bGVzLlxuICAgIGNvbnN0IGNsZWFyU3R5bGVzID0ge1xuICAgICAgJ21heC13aWR0aCc6IG51bGwsXG4gICAgICAnbWF4LWhlaWdodCc6IG51bGwsXG4gICAgICAnbWluLXdpZHRoJzogbnVsbCxcbiAgICAgICdtaW4taGVpZ2h0JzogbnVsbFxuICAgIH07XG4gICAgc3dpdGNoIChiYXNpcyB8fCAnJykge1xuICAgICAgY2FzZSAnJzpcbiAgICAgICAgY29uc3QgdXNlQ29sdW1uQmFzaXNaZXJvID0gdGhpcy5sYXlvdXRDb25maWcudXNlQ29sdW1uQmFzaXNaZXJvICE9PSBmYWxzZTtcbiAgICAgICAgYmFzaXMgPSBkaXJlY3Rpb24gPT09ICdyb3cnID8gJzAlJyA6ICh1c2VDb2x1bW5CYXNpc1plcm8gPyAnMC4wMDAwMDAwMDFweCcgOiAnYXV0bycpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luaXRpYWwnOiAgIC8vIGRlZmF1bHRcbiAgICAgIGNhc2UgJ25vZ3Jvdyc6XG4gICAgICAgIGdyb3cgPSAwO1xuICAgICAgICBiYXNpcyA9ICdhdXRvJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdncm93JzpcbiAgICAgICAgYmFzaXMgPSAnMTAwJSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbm9zaHJpbmsnOlxuICAgICAgICBzaHJpbmsgPSAwO1xuICAgICAgICBiYXNpcyA9ICdhdXRvJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdub25lJzpcbiAgICAgICAgZ3JvdyA9IDA7XG4gICAgICAgIHNocmluayA9IDA7XG4gICAgICAgIGJhc2lzID0gJ2F1dG8nO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERlZmF1bHRzIHRvIHBlcmNlbnRhZ2Ugc2l6aW5nIHVubGVzcyBgcHhgIGlzIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgIGlmICghaXNWYWx1ZSAmJiAhaXNQZXJjZW50ICYmICFpc05hTihiYXNpcyBhcyBhbnkpKSB7XG4gICAgICAgICAgYmFzaXMgPSBiYXNpcyArICclJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpeCBmb3IgaXNzdWUgMjgwXG4gICAgICAgIGlmIChiYXNpcyA9PT0gJzAlJykge1xuICAgICAgICAgIGlzVmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhc2lzID09PSAnMHB4Jykge1xuICAgICAgICAgIGJhc2lzID0gJzAlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpeCBpc3N1ZSAjNTM0NVxuICAgICAgICBpZiAoaGFzQ2FsYykge1xuICAgICAgICAgIGNzcyA9IGV4dGVuZE9iamVjdChjbGVhclN0eWxlcywge1xuICAgICAgICAgICAgJ2ZsZXgtZ3Jvdyc6IGdyb3csXG4gICAgICAgICAgICAnZmxleC1zaHJpbmsnOiBzaHJpbmssXG4gICAgICAgICAgICAnZmxleC1iYXNpcyc6IGlzVmFsdWUgPyBiYXNpcyA6ICcxMDAlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNzcyA9IGV4dGVuZE9iamVjdChjbGVhclN0eWxlcywge1xuICAgICAgICAgICAgJ2ZsZXgnOiBgJHtncm93fSAke3Nocmlua30gJHtpc1ZhbHVlID8gYmFzaXMgOiAnMTAwJSd9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCEoY3NzWydmbGV4J10gfHwgY3NzWydmbGV4LWdyb3cnXSkpIHtcbiAgICAgIGlmIChoYXNDYWxjKSB7XG4gICAgICAgIGNzcyA9IGV4dGVuZE9iamVjdChjbGVhclN0eWxlcywge1xuICAgICAgICAgICdmbGV4LWdyb3cnOiBncm93LFxuICAgICAgICAgICdmbGV4LXNocmluayc6IHNocmluayxcbiAgICAgICAgICAnZmxleC1iYXNpcyc6IGJhc2lzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzID0gZXh0ZW5kT2JqZWN0KGNsZWFyU3R5bGVzLCB7XG4gICAgICAgICAgJ2ZsZXgnOiBgJHtncm93fSAke3Nocmlua30gJHtiYXNpc31gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpeCBmb3IgaXNzdWVzIDI3NywgNTM0LCBhbmQgNzI4XG4gICAgaWYgKGJhc2lzICE9PSAnMCUnICYmIGJhc2lzICE9PSAnMHB4JyAmJiBiYXNpcyAhPT0gJzAuMDAwMDAwMDAxcHgnICYmIGJhc2lzICE9PSAnYXV0bycpIHtcbiAgICAgIGNzc1ttaW5dID0gaXNGaXhlZCB8fCAoaXNWYWx1ZSAmJiBncm93KSA/IGJhc2lzIDogbnVsbDtcbiAgICAgIGNzc1ttYXhdID0gaXNGaXhlZCB8fCAoIXVzaW5nQ2FsYyAmJiBzaHJpbmspID8gYmFzaXMgOiBudWxsO1xuICAgIH1cblxuICAgIC8vIEZpeCBmb3IgaXNzdWUgNTI4XG4gICAgaWYgKCFjc3NbbWluXSAmJiAhY3NzW21heF0pIHtcbiAgICAgIGlmIChoYXNDYWxjKSB7XG4gICAgICAgIGNzcyA9IGV4dGVuZE9iamVjdChjbGVhclN0eWxlcywge1xuICAgICAgICAgICdmbGV4LWdyb3cnOiBncm93LFxuICAgICAgICAgICdmbGV4LXNocmluayc6IHNocmluayxcbiAgICAgICAgICAnZmxleC1iYXNpcyc6IGJhc2lzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzID0gZXh0ZW5kT2JqZWN0KGNsZWFyU3R5bGVzLCB7XG4gICAgICAgICAgJ2ZsZXgnOiBgJHtncm93fSAke3Nocmlua30gJHtiYXNpc31gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaXggZm9yIGlzc3VlIDY2MFxuICAgICAgaWYgKHBhcmVudC5oYXNXcmFwKSB7XG4gICAgICAgIGNzc1toYXNDYWxjID8gJ2ZsZXgtYmFzaXMnIDogJ2ZsZXgnXSA9IGNzc1ttYXhdID9cbiAgICAgICAgICAoaGFzQ2FsYyA/IGNzc1ttYXhdIDogYCR7Z3Jvd30gJHtzaHJpbmt9ICR7Y3NzW21heF19YCkgOlxuICAgICAgICAgIChoYXNDYWxjID8gY3NzW21pbl0gOiBgJHtncm93fSAke3Nocmlua30gJHtjc3NbbWluXX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kT2JqZWN0KGNzcywgeydib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnfSkgYXMgU3R5bGVEZWZpbml0aW9uO1xuICB9XG59XG5cbmNvbnN0IGlucHV0cyA9IFtcbiAgJ2Z4RmxleCcsICdmeEZsZXgueHMnLCAnZnhGbGV4LnNtJywgJ2Z4RmxleC5tZCcsXG4gICdmeEZsZXgubGcnLCAnZnhGbGV4LnhsJywgJ2Z4RmxleC5sdC1zbScsICdmeEZsZXgubHQtbWQnLFxuICAnZnhGbGV4Lmx0LWxnJywgJ2Z4RmxleC5sdC14bCcsICdmeEZsZXguZ3QteHMnLCAnZnhGbGV4Lmd0LXNtJyxcbiAgJ2Z4RmxleC5ndC1tZCcsICdmeEZsZXguZ3QtbGcnXG5dO1xuY29uc3Qgc2VsZWN0b3IgPSBgXG4gIFtmeEZsZXhdLCBbZnhGbGV4LnhzXSwgW2Z4RmxleC5zbV0sIFtmeEZsZXgubWRdLFxuICBbZnhGbGV4LmxnXSwgW2Z4RmxleC54bF0sIFtmeEZsZXgubHQtc21dLCBbZnhGbGV4Lmx0LW1kXSxcbiAgW2Z4RmxleC5sdC1sZ10sIFtmeEZsZXgubHQteGxdLCBbZnhGbGV4Lmd0LXhzXSwgW2Z4RmxleC5ndC1zbV0sXG4gIFtmeEZsZXguZ3QtbWRdLCBbZnhGbGV4Lmd0LWxnXVxuYDtcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gY29udHJvbCB0aGUgc2l6ZSBvZiBhIGZsZXggaXRlbSB1c2luZyBmbGV4LWJhc2lzLCBmbGV4LWdyb3csIGFuZCBmbGV4LXNocmluay5cbiAqIENvcnJlc3BvbmRzIHRvIHRoZSBjc3MgYGZsZXhgIHNob3J0aGFuZCBwcm9wZXJ0eS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc25pcHBldHMvY3NzL2EtZ3VpZGUtdG8tZmxleGJveC9cbiAqL1xuQERpcmVjdGl2ZSgpXG5leHBvcnQgY2xhc3MgRmxleERpcmVjdGl2ZSBleHRlbmRzIEJhc2VEaXJlY3RpdmUyIGltcGxlbWVudHMgT25Jbml0IHtcblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgRElSRUNUSVZFX0tFWSA9ICdmbGV4JztcbiAgcHJvdGVjdGVkIGRpcmVjdGlvbj86IHN0cmluZyA9IHVuZGVmaW5lZDtcbiAgcHJvdGVjdGVkIHdyYXA/OiBib29sZWFuID0gdW5kZWZpbmVkO1xuXG5cbiAgQElucHV0KCdmeFNocmluaycpXG4gIGdldCBzaHJpbmsoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuZmxleFNocmluazsgfVxuICBzZXQgc2hyaW5rKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmZsZXhTaHJpbmsgPSB2YWx1ZSB8fCAnMSc7XG4gICAgdGhpcy50cmlnZ2VyUmVmbG93KCk7XG4gIH1cblxuICBASW5wdXQoJ2Z4R3JvdycpXG4gIGdldCBncm93KCk6IHN0cmluZyB7IHJldHVybiB0aGlzLmZsZXhHcm93OyB9XG4gIHNldCBncm93KHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmZsZXhHcm93ID0gdmFsdWUgfHwgJzEnO1xuICAgIHRoaXMudHJpZ2dlclJlZmxvdygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGZsZXhHcm93ID0gJzEnO1xuICBwcm90ZWN0ZWQgZmxleFNocmluayA9ICcxJztcblxuICBjb25zdHJ1Y3RvcihlbFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgc3R5bGVVdGlsczogU3R5bGVVdGlscyxcbiAgICAgICAgICAgICAgQEluamVjdChMQVlPVVRfQ09ORklHKSBwcm90ZWN0ZWQgbGF5b3V0Q29uZmlnOiBMYXlvdXRDb25maWdPcHRpb25zLFxuICAgICAgICAgICAgICBzdHlsZUJ1aWxkZXI6IEZsZXhTdHlsZUJ1aWxkZXIsXG4gICAgICAgICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSBtYXJzaGFsOiBNZWRpYU1hcnNoYWxsZXIpIHtcbiAgICBzdXBlcihlbFJlZiwgc3R5bGVCdWlsZGVyLCBzdHlsZVV0aWxzLCBtYXJzaGFsKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICh0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMubWFyc2hhbC50cmFja1ZhbHVlKHRoaXMucGFyZW50RWxlbWVudCwgJ2xheW91dCcpXG4gICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3lTdWJqZWN0KSlcbiAgICAgICAgLnN1YnNjcmliZSh0aGlzLm9uTGF5b3V0Q2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5tYXJzaGFsLnRyYWNrVmFsdWUodGhpcy5uYXRpdmVFbGVtZW50LCAnbGF5b3V0LWFsaWduJylcbiAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveVN1YmplY3QpKVxuICAgICAgICAuc3Vic2NyaWJlKHRoaXMudHJpZ2dlclJlZmxvdy5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FjaGVzIHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgJ2ZsZXgtZGlyZWN0aW9uJyBhbmQgdXBkYXRlcyB0aGUgZWxlbWVudCdzIHN0eWxlLlxuICAgKiBVc2VkIGFzIGEgaGFuZGxlciBmb3IgbGF5b3V0IGNoYW5nZSBldmVudHMgZnJvbSB0aGUgcGFyZW50IGZsZXggY29udGFpbmVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIG9uTGF5b3V0Q2hhbmdlKG1hdGNoZXI6IEVsZW1lbnRNYXRjaGVyKSB7XG4gICAgY29uc3QgbGF5b3V0OiBzdHJpbmcgPSBtYXRjaGVyLnZhbHVlO1xuICAgIGNvbnN0IGxheW91dFBhcnRzID0gbGF5b3V0LnNwbGl0KCcgJyk7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBsYXlvdXRQYXJ0c1swXTtcbiAgICB0aGlzLndyYXAgPSBsYXlvdXRQYXJ0c1sxXSAhPT0gdW5kZWZpbmVkICYmIGxheW91dFBhcnRzWzFdID09PSAnd3JhcCc7XG4gICAgdGhpcy50cmlnZ2VyVXBkYXRlKCk7XG4gIH1cblxuICAvKiogSW5wdXQgdG8gdGhpcyBpcyBleGNsdXNpdmVseSB0aGUgYmFzaXMgaW5wdXQgdmFsdWUgKi9cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIHVwZGF0ZVdpdGhWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgYWRkRmxleFRvUGFyZW50ID0gdGhpcy5sYXlvdXRDb25maWcuYWRkRmxleFRvUGFyZW50ICE9PSBmYWxzZTtcbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLmdldEZsZXhGbG93RGlyZWN0aW9uKHRoaXMucGFyZW50RWxlbWVudCEsIGFkZEZsZXhUb1BhcmVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLndyYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53cmFwID0gdGhpcy5oYXNXcmFwKHRoaXMucGFyZW50RWxlbWVudCEpO1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24uc3RhcnRzV2l0aCgncm93Jyk7XG4gICAgY29uc3QgaGFzV3JhcCA9IHRoaXMud3JhcDtcbiAgICBpZiAoaXNIb3Jpem9udGFsICYmIGhhc1dyYXApIHtcbiAgICAgIHRoaXMuc3R5bGVDYWNoZSA9IGZsZXhSb3dXcmFwQ2FjaGU7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwgJiYgIWhhc1dyYXApIHtcbiAgICAgIHRoaXMuc3R5bGVDYWNoZSA9IGZsZXhSb3dDYWNoZTtcbiAgICB9IGVsc2UgaWYgKCFpc0hvcml6b250YWwgJiYgaGFzV3JhcCkge1xuICAgICAgdGhpcy5zdHlsZUNhY2hlID0gZmxleENvbHVtbldyYXBDYWNoZTtcbiAgICB9IGVsc2UgaWYgKCFpc0hvcml6b250YWwgJiYgIWhhc1dyYXApIHtcbiAgICAgIHRoaXMuc3R5bGVDYWNoZSA9IGZsZXhDb2x1bW5DYWNoZTtcbiAgICB9XG4gICAgY29uc3QgYmFzaXMgPSBTdHJpbmcodmFsdWUpLnJlcGxhY2UoJzsnLCAnJyk7XG4gICAgY29uc3QgcGFydHMgPSB2YWxpZGF0ZUJhc2lzKGJhc2lzLCB0aGlzLmZsZXhHcm93LCB0aGlzLmZsZXhTaHJpbmspO1xuICAgIHRoaXMuYWRkU3R5bGVzKHBhcnRzLmpvaW4oJyAnKSwge2RpcmVjdGlvbiwgaGFzV3JhcH0pO1xuICB9XG5cbiAgLyoqIFRyaWdnZXIgYSBzdHlsZSByZWZsb3csIHVzdWFsbHkgYmFzZWQgb24gYSBzaHJpbmsvZ3JvdyBpbnB1dCBldmVudCAqL1xuICBwcm90ZWN0ZWQgdHJpZ2dlclJlZmxvdygpIHtcbiAgICBjb25zdCBhY3RpdmF0ZWRWYWx1ZSA9IHRoaXMuYWN0aXZhdGVkVmFsdWU7XG4gICAgaWYgKGFjdGl2YXRlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsaWRhdGVCYXNpcyhhY3RpdmF0ZWRWYWx1ZSArICcnLCB0aGlzLmZsZXhHcm93LCB0aGlzLmZsZXhTaHJpbmspO1xuICAgICAgdGhpcy5tYXJzaGFsLnVwZGF0ZUVsZW1lbnQodGhpcy5uYXRpdmVFbGVtZW50LCB0aGlzLkRJUkVDVElWRV9LRVksIHBhcnRzLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG59XG5cbkBEaXJlY3RpdmUoe2lucHV0cywgc2VsZWN0b3J9KVxuZXhwb3J0IGNsYXNzIERlZmF1bHRGbGV4RGlyZWN0aXZlIGV4dGVuZHMgRmxleERpcmVjdGl2ZSB7XG4gIHByb3RlY3RlZCBvdmVycmlkZSBpbnB1dHMgPSBpbnB1dHM7XG59XG5cbmNvbnN0IGZsZXhSb3dDYWNoZTogTWFwPHN0cmluZywgU3R5bGVEZWZpbml0aW9uPiA9IG5ldyBNYXAoKTtcbmNvbnN0IGZsZXhDb2x1bW5DYWNoZTogTWFwPHN0cmluZywgU3R5bGVEZWZpbml0aW9uPiA9IG5ldyBNYXAoKTtcbmNvbnN0IGZsZXhSb3dXcmFwQ2FjaGU6IE1hcDxzdHJpbmcsIFN0eWxlRGVmaW5pdGlvbj4gPSBuZXcgTWFwKCk7XG5jb25zdCBmbGV4Q29sdW1uV3JhcENhY2hlOiBNYXA8c3RyaW5nLCBTdHlsZURlZmluaXRpb24+ID0gbmV3IE1hcCgpO1xuIl19